import React, { useState, useEffect, useMemo } from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, BarChart, Bar } from 'recharts';

const ProbabilityDistributionsExplorer = () => {
  const [selectedDistribution, setSelectedDistribution] = useState('normal');
  const [parameters, setParameters] = useState({});
  const [showCDF, setShowCDF] = useState(false);
  const [selectedCategory, setSelectedCategory] = useState('continuous');

  // Distribution definitions
  const distributions = {
    continuous: {
      normal: {
        name: 'Normal Distribution',
        params: { mu: 0, sigma: 1 },
        ranges: { mu: [-5, 5], sigma: [0.1, 3] },
        description: 'Bell-shaped curve, most important distribution in statistics'
      },
      uniform: {
        name: 'Uniform Distribution',
        params: { a: 0, b: 1 },
        ranges: { a: [-2, 2], b: [0, 4] },
        description: 'All values in interval equally likely'
      },
      exponential: {
        name: 'Exponential Distribution',
        params: { lambda: 1 },
        ranges: { lambda: [0.1, 3] },
        description: 'Models waiting times between events'
      },
      gamma: {
        name: 'Gamma Distribution',
        params: { alpha: 2, beta: 1 },
        ranges: { alpha: [0.5, 5], beta: [0.1, 3] },
        description: 'Generalizes exponential distribution'
      },
      beta: {
        name: 'Beta Distribution',
        params: { alpha: 2, beta: 2 },
        ranges: { alpha: [0.5, 5], beta: [0.5, 5] },
        description: 'Defined on [0,1] interval'
      },
      weibull: {
        name: 'Weibull Distribution',
        params: { k: 2, lambda: 1 },
        ranges: { k: [0.5, 3], lambda: [0.5, 3] },
        description: 'Models reliability and survival times'
      },
      lognormal: {
        name: 'Lognormal Distribution',
        params: { mu: 0, sigma: 1 },
        ranges: { mu: [-1, 1], sigma: [0.1, 1.5] },
        description: 'Logarithm is normally distributed'
      },
      t: {
        name: 'Student\'s t-Distribution',
        params: { df: 5 },
        ranges: { df: [1, 20] },
        description: 'Used when population variance unknown'
      },
      chisquare: {
        name: 'Chi-Square Distribution',
        params: { df: 3 },
        ranges: { df: [1, 10] },
        description: 'Sum of squared standard normal variables'
      },
      f: {
        name: 'F-Distribution',
        params: { df1: 5, df2: 10 },
        ranges: { df1: [1, 10], df2: [1, 20] },
        description: 'Ratio of two chi-square distributions'
      }
    },
    discrete: {
      bernoulli: {
        name: 'Bernoulli Distribution',
        params: { p: 0.5 },
        ranges: { p: [0.01, 0.99] },
        description: 'Single trial with two outcomes'
      },
      binomial: {
        name: 'Binomial Distribution',
        params: { n: 10, p: 0.5 },
        ranges: { n: [1, 30], p: [0.01, 0.99] },
        description: 'Number of successes in n trials'
      },
      geometric: {
        name: 'Geometric Distribution',
        params: { p: 0.3 },
        ranges: { p: [0.01, 0.99] },
        description: 'Number of trials until first success'
      },
      poisson: {
        name: 'Poisson Distribution',
        params: { lambda: 3 },
        ranges: { lambda: [0.1, 10] },
        description: 'Number of events in fixed interval'
      },
      negbinomial: {
        name: 'Negative Binomial Distribution',
        params: { r: 3, p: 0.4 },
        ranges: { r: [1, 10], p: [0.01, 0.99] },
        description: 'Number of trials until r-th success'
      },
      hypergeometric: {
        name: 'Hypergeometric Distribution',
        params: { N: 20, K: 7, n: 10 },
        ranges: { N: [10, 50], K: [1, 25], n: [1, 25] },
        description: 'Sampling without replacement'
      },
      discrete_uniform: {
        name: 'Discrete Uniform Distribution',
        params: { a: 1, b: 6 },
        ranges: { a: [1, 5], b: [2, 10] },
        description: 'All outcomes equally likely'
      }
    }
  };

  // Initialize parameters when distribution changes
  useEffect(() => {
    if (distributions[selectedCategory][selectedDistribution]) {
      setParameters(distributions[selectedCategory][selectedDistribution].params);
    }
  }, [selectedDistribution, selectedCategory]);

  // Mathematical functions
  const gamma = (z) => {
    // Stirling's approximation for gamma function
    if (z < 0.5) return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
    z -= 1;
    let x = 0.99999999999980993;
    const p = [676.5203681218851, -1259.1392167224028, 771.32342877765313, 
              -176.61502916214059, 12.507343278686905, -0.13857109526572012, 
              9.9843695780195716e-6, 1.5056327351493116e-7];
    for (let i = 0; i < p.length; i++) {
      x += p[i] / (z + i + 1);
    }
    const t = z + p.length - 0.5;
    return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
  };

  const factorial = (n) => {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
  };

  const binomialCoeff = (n, k) => {
    if (k > n) return 0;
    if (k === 0 || k === n) return 1;
    return factorial(n) / (factorial(k) * factorial(n - k));
  };

  // PDF/PMF functions
  const getPDF = (x, dist, params) => {
    switch (dist) {
      case 'normal':
        return (1 / (params.sigma * Math.sqrt(2 * Math.PI))) * 
               Math.exp(-0.5 * Math.pow((x - params.mu) / params.sigma, 2));
      
      case 'uniform':
        return (x >= params.a && x <= params.b) ? 1 / (params.b - params.a) : 0;
      
      case 'exponential':
        return x >= 0 ? params.lambda * Math.exp(-params.lambda * x) : 0;
      
      case 'gamma':
        return x >= 0 ? 
          (Math.pow(params.beta, params.alpha) / gamma(params.alpha)) * 
          Math.pow(x, params.alpha - 1) * Math.exp(-params.beta * x) : 0;
      
      case 'beta':
        return (x >= 0 && x <= 1) ? 
          (gamma(params.alpha + params.beta) / (gamma(params.alpha) * gamma(params.beta))) * 
          Math.pow(x, params.alpha - 1) * Math.pow(1 - x, params.beta - 1) : 0;
      
      case 'weibull':
        return x >= 0 ? 
          (params.k / params.lambda) * Math.pow(x / params.lambda, params.k - 1) * 
          Math.exp(-Math.pow(x / params.lambda, params.k)) : 0;
      
      case 'lognormal':
        return x > 0 ? 
          (1 / (x * params.sigma * Math.sqrt(2 * Math.PI))) * 
          Math.exp(-0.5 * Math.pow((Math.log(x) - params.mu) / params.sigma, 2)) : 0;
      
      case 't':
        return (gamma((params.df + 1) / 2) / (Math.sqrt(params.df * Math.PI) * gamma(params.df / 2))) * 
               Math.pow(1 + x * x / params.df, -(params.df + 1) / 2);
      
      case 'chisquare':
        return x >= 0 ? 
          (1 / (Math.pow(2, params.df / 2) * gamma(params.df / 2))) * 
          Math.pow(x, params.df / 2 - 1) * Math.exp(-x / 2) : 0;
      
      case 'f':
        return x >= 0 ? 
          (gamma((params.df1 + params.df2) / 2) / (gamma(params.df1 / 2) * gamma(params.df2 / 2))) * 
          Math.pow(params.df1 / params.df2, params.df1 / 2) * 
          Math.pow(x, params.df1 / 2 - 1) * 
          Math.pow(1 + (params.df1 / params.df2) * x, -(params.df1 + params.df2) / 2) : 0;
      
      default:
        return 0;
    }
  };

  const getPMF = (x, dist, params) => {
    switch (dist) {
      case 'bernoulli':
        return x === 1 ? params.p : (x === 0 ? 1 - params.p : 0);
      
      case 'binomial':
        return x >= 0 && x <= params.n ? 
          binomialCoeff(params.n, x) * Math.pow(params.p, x) * Math.pow(1 - params.p, params.n - x) : 0;
      
      case 'geometric':
        return x >= 1 ? Math.pow(1 - params.p, x - 1) * params.p : 0;
      
      case 'poisson':
        return x >= 0 ? (Math.pow(params.lambda, x) * Math.exp(-params.lambda)) / factorial(x) : 0;
      
      case 'negbinomial':
        return x >= params.r ? 
          binomialCoeff(x - 1, params.r - 1) * Math.pow(params.p, params.r) * Math.pow(1 - params.p, x - params.r) : 0;
      
      case 'hypergeometric':
        const maxVal = Math.min(params.n, params.K);
        const minVal = Math.max(0, params.n - params.N + params.K);
        return (x >= minVal && x <= maxVal) ? 
          (binomialCoeff(params.K, x) * binomialCoeff(params.N - params.K, params.n - x)) / 
          binomialCoeff(params.N, params.n) : 0;
      
      case 'discrete_uniform':
        return (x >= params.a && x <= params.b && Number.isInteger(x)) ? 
          1 / (params.b - params.a + 1) : 0;
      
      default:
        return 0;
    }
  };

  // Generate data for plotting
  const generateData = useMemo(() => {
    if (!parameters || Object.keys(parameters).length === 0) return [];
    
    const data = [];
    const isDiscrete = selectedCategory === 'discrete';
    
    if (isDiscrete) {
      let start, end;
      
      switch (selectedDistribution) {
        case 'bernoulli':
          start = 0; end = 1;
          break;
        case 'binomial':
          start = 0; end = parameters.n;
          break;
        case 'geometric':
          start = 1; end = Math.min(20, Math.ceil(3 / parameters.p));
          break;
        case 'poisson':
          start = 0; end = Math.min(20, parameters.lambda + 4 * Math.sqrt(parameters.lambda));
          break;
        case 'negbinomial':
          start = parameters.r; end = Math.min(30, parameters.r + Math.ceil(10 / parameters.p));
          break;
        case 'hypergeometric':
          start = Math.max(0, parameters.n - parameters.N + parameters.K);
          end = Math.min(parameters.n, parameters.K);
          break;
        case 'discrete_uniform':
          start = parameters.a; end = parameters.b;
          break;
        default:
          start = 0; end = 10;
      }
      
      for (let x = start; x <= end; x++) {
        const prob = getPMF(x, selectedDistribution, parameters);
        if (prob > 0 || x === start || x === end) {
          data.push({ x, pdf: prob, cdf: 0 });
        }
      }
    } else {
      let start, end, step;
      
      switch (selectedDistribution) {
        case 'normal':
          start = parameters.mu - 4 * parameters.sigma;
          end = parameters.mu + 4 * parameters.sigma;
          step = (end - start) / 200;
          break;
        case 'uniform':
          start = parameters.a - 0.5;
          end = parameters.b + 0.5;
          step = (end - start) / 200;
          break;
        case 'exponential':
        case 'gamma':
        case 'weibull':
        case 'chisquare':
        case 'f':
          start = 0;
          end = 10;
          step = 0.05;
          break;
        case 'beta':
          start = 0;
          end = 1;
          step = 0.005;
          break;
        case 'lognormal':
          start = 0.01;
          end = 5;
          step = 0.025;
          break;
        case 't':
          start = -5;
          end = 5;
          step = 0.05;
          break;
        default:
          start = -5; end = 5; step = 0.05;
      }
      
      for (let x = start; x <= end; x += step) {
        const prob = getPDF(x, selectedDistribution, parameters);
        data.push({ x: Number(x.toFixed(3)), pdf: prob, cdf: 0 });
      }
    }
    
    return data;
  }, [selectedDistribution, parameters, selectedCategory]);

  // Calculate statistics
  const calculateStats = () => {
    const dist = distributions[selectedCategory][selectedDistribution];
    const params = parameters;
    
    let mean, variance;
    
    if (selectedCategory === 'continuous') {
      switch (selectedDistribution) {
        case 'normal':
          mean = params.mu;
          variance = params.sigma * params.sigma;
          break;
        case 'uniform':
          mean = (params.a + params.b) / 2;
          variance = Math.pow(params.b - params.a, 2) / 12;
          break;
        case 'exponential':
          mean = 1 / params.lambda;
          variance = 1 / (params.lambda * params.lambda);
          break;
        case 'gamma':
          mean = params.alpha / params.beta;
          variance = params.alpha / (params.beta * params.beta);
          break;
        case 'beta':
          mean = params.alpha / (params.alpha + params.beta);
          variance = (params.alpha * params.beta) / (Math.pow(params.alpha + params.beta, 2) * (params.alpha + params.beta + 1));
          break;
        case 'weibull':
          mean = params.lambda * gamma(1 + 1 / params.k);
          variance = params.lambda * params.lambda * (gamma(1 + 2 / params.k) - Math.pow(gamma(1 + 1 / params.k), 2));
          break;
        case 'lognormal':
          mean = Math.exp(params.mu + params.sigma * params.sigma / 2);
          variance = (Math.exp(params.sigma * params.sigma) - 1) * Math.exp(2 * params.mu + params.sigma * params.sigma);
          break;
        case 't':
          mean = params.df > 1 ? 0 : 'Undefined';
          variance = params.df > 2 ? params.df / (params.df - 2) : 'Undefined';
          break;
        case 'chisquare':
          mean = params.df;
          variance = 2 * params.df;
          break;
        case 'f':
          mean = params.df2 > 2 ? params.df2 / (params.df2 - 2) : 'Undefined';
          variance = params.df2 > 4 ? (2 * params.df2 * params.df2 * (params.df1 + params.df2 - 2)) / (params.df1 * (params.df2 - 2) * (params.df2 - 2) * (params.df2 - 4)) : 'Undefined';
          break;
        default:
          mean = 'N/A';
          variance = 'N/A';
      }
    } else {
      switch (selectedDistribution) {
        case 'bernoulli':
          mean = params.p;
          variance = params.p * (1 - params.p);
          break;
        case 'binomial':
          mean = params.n * params.p;
          variance = params.n * params.p * (1 - params.p);
          break;
        case 'geometric':
          mean = 1 / params.p;
          variance = (1 - params.p) / (params.p * params.p);
          break;
        case 'poisson':
          mean = params.lambda;
          variance = params.lambda;
          break;
        case 'negbinomial':
          mean = params.r / params.p;
          variance = params.r * (1 - params.p) / (params.p * params.p);
          break;
        case 'hypergeometric':
          mean = params.n * params.K / params.N;
          variance = params.n * (params.K / params.N) * (1 - params.K / params.N) * (params.N - params.n) / (params.N - 1);
          break;
        case 'discrete_uniform':
          mean = (params.a + params.b) / 2;
          variance = ((params.b - params.a + 1) * (params.b - params.a + 1) - 1) / 12;
          break;
        default:
          mean = 'N/A';
          variance = 'N/A';
      }
    }
    
    return { mean, variance, stddev: typeof variance === 'number' ? Math.sqrt(variance) : 'N/A' };
  };

  const stats = calculateStats();

  const handleParameterChange = (param, value) => {
    setParameters(prev => ({ ...prev, [param]: parseFloat(value) }));
  };

  const currentDist = distributions[selectedCategory][selectedDistribution];

  return (
    <div className="w-full max-w-7xl mx-auto p-6 bg-white">
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-gray-900 mb-2">Interactive Probability Distributions Explorer</h1>
        <p className="text-gray-600">Explore and understand probability distributions with interactive visualizations</p>
      </div>

      {/* Distribution Selection */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">Category</label>
          <select 
            value={selectedCategory} 
            onChange={(e) => setSelectedCategory(e.target.value)}
            className="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          >
            <option value="continuous">Continuous Distributions</option>
            <option value="discrete">Discrete Distributions</option>
          </select>
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">Distribution</label>
          <select 
            value={selectedDistribution} 
            onChange={(e) => setSelectedDistribution(e.target.value)}
            className="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          >
            {Object.entries(distributions[selectedCategory]).map(([key, dist]) => (
              <option key={key} value={key}>{dist.name}</option>
            ))}
          </select>
        </div>
      </div>

      {/* Parameters */}
      <div className="bg-gray-50 rounded-lg p-6 mb-8">
        <h3 className="text-lg font-semibold mb-4">Parameters</h3>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {currentDist && Object.keys(currentDist.params).map(param => (
            <div key={param}>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                {param === 'mu' ? 'μ (mean)' : 
                 param === 'sigma' ? 'σ (std dev)' : 
                 param === 'lambda' ? 'λ (rate)' :
                 param === 'alpha' ? 'α (shape)' :
                 param === 'beta' ? 'β (rate/shape)' :
                 param === 'df' ? 'degrees of freedom' :
                 param === 'df1' ? 'df1' :
                 param === 'df2' ? 'df2' :
                 param}
              </label>
              <input
                type="range"
                min={currentDist.ranges[param][0]}
                max={currentDist.ranges[param][1]}
                step={param === 'n' || param === 'r' || param === 'df' || param === 'df1' || param === 'df2' || param === 'N' || param === 'K' || param === 'a' || param === 'b' ? 1 : 0.1}
                value={parameters[param] || currentDist.params[param]}
                onChange={(e) => handleParameterChange(param, e.target.value)}
                className="w-full"
              />
              <div className="text-sm text-gray-500 mt-1">
                {parameters[param] || currentDist.params[param]}
              </div>
            </div>
          ))}
        </div>
        
        <div className="mt-4 p-4 bg-blue-50 rounded-lg">
          <p className="text-sm text-blue-800">{currentDist?.description}</p>
        </div>
      </div>

      {/* Statistics */}
      <div className="bg-green-50 rounded-lg p-6 mb-8">
        <h3 className="text-lg font-semibold mb-4">Distribution Statistics</h3>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div className="text-center">
            <div className="text-2xl font-bold text-green-700">
              {typeof stats.mean === 'number' ? stats.mean.toFixed(3) : stats.mean}
            </div>
            <div className="text-sm text-gray-600">Mean (μ)</div>
          </div>
          <div className="text-center">
            <div className="text-2xl font-bold text-green-700">
              {typeof stats.variance === 'number' ? stats.variance.toFixed(3) : stats.variance}
            </div>
            <div className="text-sm text-gray-600">Variance (σ²)</div>
          </div>
          <div className="text-center">
            <div className="text-2xl font-bold text-green-700">
              {typeof stats.stddev === 'number' ? stats.stddev.toFixed(3) : stats.stddev}
            </div>
            <div className="text-sm text-gray-600">Standard Deviation (σ)</div>
          </div>
        </div>
      </div>

      {/* Visualization */}
      <div className="bg-white border rounded-lg p-6 mb-8">
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-lg font-semibold">
            {selectedCategory === 'discrete' ? 'Probability Mass Function (PMF)' : 'Probability Density Function (PDF)'}
          </h3>
          <button
            onClick={() => setShowCDF(!showCDF)}
            className="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors"
          >
            {showCDF ? 'Show PDF/PMF' : 'Show CDF'}
          </button>
        </div>
        
        <div className="h-96">
          <ResponsiveContainer width="100%" height="100%">
            {selectedCategory === 'discrete' ? (
              <BarChart data={generateData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="x" />
                <YAxis />
                <Tooltip formatter={(value) => [value.toFixed(4), 'Probability']} />
                <Bar dataKey="pdf" fill="#3B82F6" />
              </BarChart>
            ) : (
              <LineChart data={generateData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="x" />
                <YAxis />
                <Tooltip formatter={(value) => [value.toFixed(4), 'Density']} />
                <Line 
                  type="monotone" 
                  dataKey="pdf" 
                  stroke="#3B82F6" 
                  strokeWidth={2}
                  dot={false}
                />
              </LineChart>
            )}
          </ResponsiveContainer>
        </div>
      </div>

      {/* Key Concepts */}
      <div className="bg-gray-50 rounded-lg p-6">
        <h3 className="text-lg font-semibold mb-4">Key Concepts</h3>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <h4 className="font-medium mb-2">Discrete vs Continuous</h4>
            <p className="text-sm text-gray-600">
              <strong>Discrete:</strong> Countable outcomes (like coin flips). Uses Probability Mass Function (PMF).<br/>
              <strong>Continuous:</strong> Uncountable outcomes (like height). Uses Probability Density Function (PDF).
            </p>
          </div>
          <div>
            <h4 className="font-medium mb-2">Parameters</h4>
            <p className="text-sm text-gray-600">
              Parameters control the shape, location, and scale of distributions. 
              Changing them lets you see how distributions behave under different conditions.
            </p>
          </div>
          <div>
            <h4 className="font-medium mb-2">Mean & Variance</h4>
            <p className="text-sm text-gray-600">
              <strong>Mean (μ):</strong> Expected value or center of distribution.<br/>
              <strong>Variance (σ²):</strong> How spread out the values are.<br/>
              <strong>Standard Deviation (σ):</strong> Square root of variance.
            </p>
          </div>
          <div>
            <h4 className="font-medium mb-2">Real-World Applications</h4>
            <p className="text-sm text-gray-600">
              Each distribution models different real-world phenomena. 
              Normal for heights, Poisson for rare events, Exponential for waiting times, etc.
            </p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ProbabilityDistributionsExplorer;
